1、对象创建过程
一般对象创建不包含数组
1)、检查类是否被加载，当虚拟机执行类创建指令时(new,newInstance)，会去常量池中根据类全限定名查找该类符号引用，如果找到说明此类已经被加载到
方法区，可以继续执行；如果找不到则执行类装载过程，直到类装载校验准备解析完成，继续执行
2)、为对象分配内存，类加载完后，虚拟机开始为对象分配内存，此时类所需内存大小已经确定，只需在堆上分配内存即可，
内存分配两种情况，内存空间连续规整的(通过指针移动即可)，内存空间不连续(虚拟机需要维护一个列表记录可以内存)，
3）、为分配的内存空间初始化0值，为对象赋初值，可以直接使用
4）、为对象进行设置对象头信息，包含类元数据信息、对象hashcode、gc分代年龄，偏向线程信息
5)、执行init方法，经过以上步骤对象已经创建完成，还是需要执行init方法才能创建完成使用
1、类加载过程
1）通过类全限定名获取二进制字节流
2）将字节流中的静态数据结构转化成方法区中运行时的数据
3）生成一个该类的java.lang.Class对象作为方法区中数据访问的入口
4）校验，文件格式的校验，元数据校验，字节码校验，符号引用校验
5）为类的静态变量分配内存，并初始化0值，final和static修饰的常量值会被初始化成指定的值
6）解析，把类中的符号引用转换成直接引用，
7）初始化，为静态变量赋予正确的初始化值，
 如果类没有被加载和连接，先加载连接类，如果类的直接父类没有初始化，则先初始化其直接父类
 如果类中有初始化语句，则依次执行初始化语句
 初始化只有在类主动使用的时候回才会初始化，而且只初始化一次
 
myisAm索引与innodb的索引的区别
1、myisam索引支持全文索引压缩索引，innodb不支持
2、myisam索引不支持事务，innodb支持事务
3、myisam顺序存储数据，索引叶子节点保存对应的数据行的地址，辅助索引跟主键索引相差不多；innodb主键节点同时保存数据行，其他辅助索引
保存的是主键索引的值；
4、myisam键值分离，索引载入内存，数据缓存依赖操作系统；innodb键值保存在一起，索引数据一起载入innodb缓存池；myisam主机索引按照升序排列存储
5、myisam处理字符串索引时使用增量保存的方式
聚簇索引就是主索引文件和数据文件为同一份文件，聚餐索引主要用在innodb存储引擎中。
分布式session几种实现方式
1、基于数据的session共享
2、基于redis、memcached的session，spring-session
3、基于tomcat web容器本身的session复制机制

redis相关
1、redis异步队列，list结构作为队列，rpush产生消息、lpop消费消息，lpop没有消息的时候，要适当的阻塞使用blpop当没有消息来会阻塞到消息到来
2、redis持久化，bgsave全量持久化，aof增量持久化，
jvm相关
1、运行时区域划分：栈、堆、方法区（逻辑抽象概念）、本地方法区、程序计数器
2、栈：栈帧，局部变量表，操作数栈，动态链接，方法出口，
3、方法区：静态变量，常量，类信息
4、堆：young generation(1/3堆)，old generation(2/3堆空间)，永久代(非堆，过时)，metadata space(直接内存，存放方法区的实现)
分布式事务两阶段加补偿（tcc）（一致性、可用性、分区容错性）（基本可用，软状态，最终一致性）
1、两阶段提交协议，提交订单、锁定库存，通过事务隔离级别，第一阶段先预提交，没有真正commit第二阶段真正提交，两个commit；全程加锁
2、失败重试，一直不成功的话使用定时任务重试；
try:尝试执行业务，完成所有业务检查(一致性)、预留所必须业务资源(准隔离性)，比如：预留订单、预留库存，确认接口
confirm：一阶段成功，二阶段其中一个事务失败，二阶段失败可用重试，超出重试次数全部回滚，非重要节点（比如积分、发票）这种可以异步或者用软状态预提交

I/O多路复用技术（multiplexing）是什么？
链接：https://www.zhihu.com/question/28594409/answer/52835876
下面举一个例子，模拟一个tcp服务器处理30个客户socket。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：1. 第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。2. 第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。3. 第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。


实用命令：

非压缩文件（*.log、*.txt等）使用cat/more/less/head/tail/grep/egrep/sed/awk
压缩文件（*.gz *.xz *.zip等）使用zcat/zmore/zless/zgrep/zegrep

查看tomcat运行日志 tail -f catalina.out

通过关键字搜索查看日志  cat jeewx-2015-09-20.log | grep 验证码

查看固定时间日志  cat jeewx-2015-09-20.log | grep   '2015-09-20 18:50:15'

查看最近50行日志  tail -n 50 -f catalina.out

Linux查看日志命令总结：

cat 显示整个文件

tail 命令用于显示文本文件的末尾几行

head  从文本文件的头部开始查看，head 命令用于查看一个文本文件的开头部分

more  以百分比的形式查看日志

less  跟more功能差不多，只不过less支持前后翻阅文件

linux不解压超大日志gz包直接查找特定内容:
gzip -dc myfile.gz | grep 'Exception' | more
或者
gzip -c myfile.gz | grep 'Exception' | more

JSON详解：
https://www.cnblogs.com/free-dom/p/5801866.html
https://www.cnblogs.com/cdf-opensource-007/p/7106018.html

公钥私钥的理解：
https://blog.csdn.net/weixin_36082485/article/details/53386190

rpc简单代码:
http://javatar.iteye.com/blog/1123915 

JVM通用的分代垃圾回收机制：http://www.sxt.cn/Java_jQuery_in_action/The_garbage_collection_mechanism.html
    分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。

　　1. 年轻代

　　所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。

　　2. 年老代

　　在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。

　　3. 持久代

　　用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。

http://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494926399617250.png

图4-7 堆内存的划分细节

　　·Minor GC:

　　用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)

　　·Major GC：

　　用于清理老年代区域。

　　·Full GC：

　　用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。

垃圾回收过程：

    1、新创建的对象，绝大多数都会存储在Eden中，

    2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区

    3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S2中，保证Eden和S1，均被清空。

    4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，

    5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）


挂载概念

Linux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。

注意：“挂载点”的目录需要以下几个要求：

（1）目录事先存在，可以用mkdir命令新建目录；

（2）挂载点目录不可被其他进程使用到；

（3）挂载点下原有文件将被隐藏。

关于挂载的作用一直不是很清楚，今天在阅读教材时看见了mount这个命令，发现它的用处很隐晦但非常强大。奈何教材说的不明朗，因此在网上整合了一些优秀的解释，看完之后豁然开朗。原文：https://blog.csdn.net/qq_39521554/article/details/79501714 

1.提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,...）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。

2.Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。

3.提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。

4.我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。

5.这时提问者使用了 mount /dev/sdb1 ~/Share/ ，把新硬盘的区sdb1挂载到工作目录的~/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。

6.所以Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。

7.linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。

8.我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？

9.这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。

10.插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。
---------------------
java中的环境变量path和classpath的作用:
https://blog.csdn.net/dhaiuda/article/details/79294866
https://blog.csdn.net/weixin_37730482/article/details/74465947
